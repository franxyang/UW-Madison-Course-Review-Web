generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id            String                 @id @default(cuid())
  email         String                 @unique
  emailVerified DateTime?
  name          String?
  nickname      String?
  image         String?
  role          UserRole               @default(STUDENT)
  createdAt     DateTime               @default(now())
  level         Int                    @default(0)
  title         String?
  xp            Int                    @default(0)
  accounts      Account[]
  comments      Comment[]
  reports       Report[]               @relation("ReportedBy")
  reviews       Review[]
  savedCourses  SavedCourse[]
  sessions      Session[]
  transcript    StudentCourseHistory[]
  votes         Vote[]
  auditLogs     AuditLog[]             @relation("AuditActor")
  bans          UserBan[]              @relation("BannedUser")
  bansIssued    UserBan[]              @relation("BanIssuer")
  resolvedReports Report[]             @relation("ResolvedBy")
}

model School {
  id          String       @id @default(cuid())
  name        String       @unique
  type        String       @default("school")
  parentId    String?
  courses     Course[]
  departments Department[]
  parent      School?      @relation("SchoolHierarchy", fields: [parentId], references: [id])
  children    School[]     @relation("SchoolHierarchy")

  @@index([parentId])
}

model Department {
  id       String             @id @default(cuid())
  code     String             @unique
  name     String
  schoolId String
  courses  CourseDepartment[]
  school   School             @relation(fields: [schoolId], references: [id])

  @@index([schoolId])
}

model Course {
  id                 String                   @id @default(cuid())
  code               String                   @unique
  name               String
  description        String
  credits            Int
  schoolId           String
  prerequisiteText   String?
  breadths           String?
  genEds             String?
  level              String
  avgGPA             Float?
  avgRating          Float?
  lastOffered        String?
  updatedAt          DateTime                 @updatedAt
  searchVector       Unsupported("tsvector")?
  // Cross-listed courses share the same crossListGroupId
  crossListGroupId   String?
  crossListGroup     CrossListGroup?          @relation(fields: [crossListGroupId], references: [id])
  school             School                   @relation(fields: [schoolId], references: [id])
  departments        CourseDepartment[]
  instructors        CourseInstructor[]
  gradeDistributions GradeDistribution[]
  reviews            Review[]
  savedBy            SavedCourse[]
  codeAliases        CourseCodeAlias[]
  prerequisites      Course[]                 @relation("CoursePrereqs")
  prerequisiteFor    Course[]                 @relation("CoursePrereqs")

  @@index([code])
  @@index([schoolId])
  @@index([level])
  @@index([crossListGroupId])
  @@index([searchVector], type: Gin)
}

model CourseCodeAlias {
  id                String   @id @default(cuid())
  sourceCode        String   @unique
  canonicalCourseId String
  source            String   @default("madgrades-extractor")
  createdAt         DateTime @default(now())
  canonicalCourse   Course   @relation(fields: [canonicalCourseId], references: [id], onDelete: Cascade)

  @@index([canonicalCourseId])
}

// Groups cross-listed courses together (e.g., CS 514 / MATH 514)
model CrossListGroup {
  id          String   @id @default(cuid())
  // Primary course code for display (e.g., "COMP SCI 514 / MATH 514")
  displayCode String?
  courses     Course[]
  createdAt   DateTime @default(now())
}

model CourseDepartment {
  courseId     String
  departmentId String
  course       Course     @relation(fields: [courseId], references: [id])
  department   Department @relation(fields: [departmentId], references: [id])

  @@id([courseId, departmentId])
}

model GradeDistribution {
  id           String      @id @default(cuid())
  courseId     String
  term         String
  aCount       Int         @default(0)
  abCount      Int         @default(0)
  bCount       Int         @default(0)
  bcCount      Int         @default(0)
  cCount       Int         @default(0)
  dCount       Int         @default(0)
  fCount       Int         @default(0)
  totalGraded  Int
  avgGPA       Float
  instructorId String?
  course       Course      @relation(fields: [courseId], references: [id])
  instructor   Instructor? @relation(fields: [instructorId], references: [id])

  // NOTE: Uniqueness is enforced by partial unique indexes in SQL migration:
  // 1) (courseId, term, instructorId) WHERE instructorId IS NOT NULL
  // 2) (courseId, term) WHERE instructorId IS NULL
  @@index([courseId])
  @@index([courseId, term])
  @@index([instructorId])
}

model Review {
  id              String     @id @default(cuid())
  term            String
  title           String?
  gradeReceived   Grade?
  contentRating   String
  teachingRating  String
  gradingRating   String
  workloadRating  String
  contentComment  String?
  teachingComment String?
  gradingComment  String?
  workloadComment       String?
  recommendInstructor   String?    // 'yes' | 'no' | 'neutral'
  assessments           String?
  tags            String?
  resourceLink    String?
  instructorId    String
  courseId        String
  authorId        String
  createdAt       DateTime   @default(now())
  comments        Comment[]
  reports         Report[]
  author          User       @relation(fields: [authorId], references: [id])
  course          Course     @relation(fields: [courseId], references: [id])
  instructor      Instructor @relation(fields: [instructorId], references: [id])
  votes           Vote[]
  isAnonymous           Boolean   @default(false)
  showRankWhenAnonymous Boolean   @default(false)

  // P1 Fix: Prevent duplicate reviews via DB constraint (one review per user per course+instructor)
  @@unique([authorId, courseId, instructorId])
  @@index([courseId])
  @@index([authorId])
  @@index([createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  authorId  String
  reviewId  String
  createdAt DateTime @default(now())
  author    User     @relation(fields: [authorId], references: [id])
  review    Review   @relation(fields: [reviewId], references: [id])
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  reviewId  String
  createdAt DateTime @default(now())
  review    Review   @relation(fields: [reviewId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, reviewId])
}

model Instructor {
  id                 String              @id @default(cuid())
  name               String              @unique
  nameKey            String?
  aliases            String?
  courses            CourseInstructor[]
  gradeDistributions GradeDistribution[]
  reviews            Review[]
  aliasMappings      InstructorAlias[]

  @@index([nameKey])
}

model InstructorAlias {
  id           String     @id @default(cuid())
  aliasRaw     String
  aliasKey     String
  source       String     @default("review")
  courseId     String?
  term         String?
  instructorId String
  instructor   Instructor @relation(fields: [instructorId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@index([aliasKey])
  @@index([courseId, term])
  @@index([instructorId])
  @@unique([aliasKey, instructorId])
}

model CourseInstructor {
  courseId     String
  instructorId String
  course       Course     @relation(fields: [courseId], references: [id])
  instructor   Instructor @relation(fields: [instructorId], references: [id])

  @@id([courseId, instructorId])
}

model SavedCourse {
  id        String   @id @default(cuid())
  userId    String
  courseId  String
  createdAt DateTime @default(now())
  course    Course   @relation(fields: [courseId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, courseId])
}

model Report {
  id           String    @id @default(cuid())
  reason       String
  details      String?
  status       String    @default("pending")
  reporterId   String
  reviewId     String
  createdAt    DateTime  @default(now())
  resolvedById String?
  resolvedAt   DateTime?
  resolution   String?   // "approved" | "rejected" | "escalated"
  reporter     User      @relation("ReportedBy", fields: [reporterId], references: [id])
  review       Review    @relation(fields: [reviewId], references: [id])
  resolvedBy   User?     @relation("ResolvedBy", fields: [resolvedById], references: [id])

  @@unique([reporterId, reviewId])
  @@index([status])
  @@index([reviewId])
  @@index([resolvedById])
}

model StudentCourseHistory {
  id         String @id @default(cuid())
  userId     String
  courseCode String
  term       String
  grade      Grade
  credits    Int
  user       User   @relation(fields: [userId], references: [id])
}

enum UserRole {
  STUDENT
  MODERATOR
  ADMIN
}

model AuditLog {
  id         String   @id @default(cuid())
  action     String   // e.g. "RESOLVE_REPORT", "DELETE_REVIEW", "BAN_USER", "CHANGE_ROLE"
  targetType String   // e.g. "Report", "Review", "User"
  targetId   String
  details    Json?
  actorId    String
  createdAt  DateTime @default(now())
  actor      User     @relation("AuditActor", fields: [actorId], references: [id])

  @@index([actorId])
  @@index([targetType, targetId])
  @@index([createdAt])
}

model UserBan {
  id        String    @id @default(cuid())
  userId    String
  reason    String
  bannedById String
  expiresAt DateTime?
  active    Boolean   @default(true)
  createdAt DateTime  @default(now())
  user      User      @relation("BannedUser", fields: [userId], references: [id])
  bannedBy  User      @relation("BanIssuer", fields: [bannedById], references: [id])

  @@index([userId, active])
}

enum Grade {
  A
  AB
  B
  BC
  C
  D
  F
}
