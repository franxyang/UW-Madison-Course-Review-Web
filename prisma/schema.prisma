generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id            String                 @id @default(cuid())
  email         String                 @unique
  emailVerified DateTime?
  name          String?
  image         String?
  role          UserRole               @default(STUDENT)
  createdAt     DateTime               @default(now())
  level         Int                    @default(0)
  title         String?
  xp            Int                    @default(0)
  accounts      Account[]
  comments      Comment[]
  reports       Report[]               @relation("ReportedBy")
  reviews       Review[]
  savedCourses  SavedCourse[]
  sessions      Session[]
  transcript    StudentCourseHistory[]
  votes         Vote[]
}

model School {
  id          String       @id @default(cuid())
  name        String       @unique
  type        String       @default("school")
  parentId    String?
  courses     Course[]
  departments Department[]
  parent      School?      @relation("SchoolHierarchy", fields: [parentId], references: [id])
  children    School[]     @relation("SchoolHierarchy")

  @@index([parentId])
}

model Department {
  id       String             @id @default(cuid())
  code     String             @unique
  name     String
  schoolId String
  courses  CourseDepartment[]
  school   School             @relation(fields: [schoolId], references: [id])

  @@index([schoolId])
}

model Course {
  id                 String                   @id @default(cuid())
  code               String                   @unique
  name               String
  description        String
  credits            Int
  schoolId           String
  prerequisiteText   String?
  breadths           String?
  genEds             String?
  level              String
  avgGPA             Float?
  avgRating          Float?
  lastOffered        String?
  updatedAt          DateTime                 @updatedAt
  searchVector       Unsupported("tsvector")?
  // Cross-listed courses share the same crossListGroupId
  crossListGroupId   String?
  crossListGroup     CrossListGroup?          @relation(fields: [crossListGroupId], references: [id])
  school             School                   @relation(fields: [schoolId], references: [id])
  departments        CourseDepartment[]
  instructors        CourseInstructor[]
  gradeDistributions GradeDistribution[]
  reviews            Review[]
  savedBy            SavedCourse[]
  prerequisites      Course[]                 @relation("CoursePrereqs")
  prerequisiteFor    Course[]                 @relation("CoursePrereqs")

  @@index([code])
  @@index([schoolId])
  @@index([level])
  @@index([crossListGroupId])
  @@index([searchVector], type: Gin)
}

// Groups cross-listed courses together (e.g., CS 514 / MATH 514)
model CrossListGroup {
  id          String   @id @default(cuid())
  // Primary course code for display (e.g., "COMP SCI 514 / MATH 514")
  displayCode String?
  courses     Course[]
  createdAt   DateTime @default(now())
}

model CourseDepartment {
  courseId     String
  departmentId String
  course       Course     @relation(fields: [courseId], references: [id])
  department   Department @relation(fields: [departmentId], references: [id])

  @@id([courseId, departmentId])
}

model GradeDistribution {
  id           String      @id @default(cuid())
  courseId     String
  term         String
  aCount       Int         @default(0)
  abCount      Int         @default(0)
  bCount       Int         @default(0)
  bcCount      Int         @default(0)
  cCount       Int         @default(0)
  dCount       Int         @default(0)
  fCount       Int         @default(0)
  totalGraded  Int
  avgGPA       Float
  instructorId String?
  course       Course      @relation(fields: [courseId], references: [id])
  instructor   Instructor? @relation(fields: [instructorId], references: [id])

  @@unique([courseId, term, instructorId])
  @@index([courseId])
  @@index([instructorId])
}

model Review {
  id              String     @id @default(cuid())
  term            String
  title           String?
  gradeReceived   Grade?
  contentRating   String
  teachingRating  String
  gradingRating   String
  workloadRating  String
  contentComment  String?
  teachingComment String?
  gradingComment  String?
  workloadComment       String?
  recommendInstructor   String?    // 'yes' | 'no' | 'neutral'
  assessments           String?
  tags            String?
  resourceLink    String?
  instructorId    String
  courseId        String
  authorId        String
  createdAt       DateTime   @default(now())
  comments        Comment[]
  reports         Report[]
  author          User       @relation(fields: [authorId], references: [id])
  course          Course     @relation(fields: [courseId], references: [id])
  instructor      Instructor @relation(fields: [instructorId], references: [id])
  votes           Vote[]

  @@index([courseId])
  @@index([authorId])
  @@index([createdAt])
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  authorId  String
  reviewId  String
  createdAt DateTime @default(now())
  author    User     @relation(fields: [authorId], references: [id])
  review    Review   @relation(fields: [reviewId], references: [id])
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  reviewId  String
  createdAt DateTime @default(now())
  review    Review   @relation(fields: [reviewId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, reviewId])
}

model Instructor {
  id                 String              @id @default(cuid())
  name               String              @unique
  aliases            String?
  courses            CourseInstructor[]
  gradeDistributions GradeDistribution[]
  reviews            Review[]
}

model CourseInstructor {
  courseId     String
  instructorId String
  course       Course     @relation(fields: [courseId], references: [id])
  instructor   Instructor @relation(fields: [instructorId], references: [id])

  @@id([courseId, instructorId])
}

model SavedCourse {
  id        String   @id @default(cuid())
  userId    String
  courseId  String
  createdAt DateTime @default(now())
  course    Course   @relation(fields: [courseId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, courseId])
}

model Report {
  id         String   @id @default(cuid())
  reason     String
  details    String?
  status     String   @default("pending")
  reporterId String
  reviewId   String
  createdAt  DateTime @default(now())
  reporter   User     @relation("ReportedBy", fields: [reporterId], references: [id])
  review     Review   @relation(fields: [reviewId], references: [id])

  @@unique([reporterId, reviewId])
  @@index([status])
  @@index([reviewId])
}

model StudentCourseHistory {
  id         String @id @default(cuid())
  userId     String
  courseCode String
  term       String
  grade      Grade
  credits    Int
  user       User   @relation(fields: [userId], references: [id])
}

enum UserRole {
  STUDENT
  ADMIN
}

enum Grade {
  A
  AB
  B
  BC
  C
  D
  F
}
